/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Resource allocations for each process
    Nodes: 384 CPUs, ~1.5 TB RAM each (shared)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

// check_max() replaced by inline [requested, cap].min() for v2 config parser

process {
   // --- Defaults ---
    cpus          = { [1,    params.max_cpus   as int].min() }
    memory        = { [4.GB, params.max_memory as nextflow.util.MemoryUnit].min() }
    time          = { [1.h,  params.max_time   as nextflow.util.Duration].min() }

   // Retry on OOM / SLURM memory-kill / NFS SIGBUS exit codes
    errorStrategy = { task.exitStatus in [104, 134, 135, 137, 139, 140, 143, 247] ? 'retry' : 'finish' }
    maxRetries    = 2

   // -- SortMeRNA ---------------------------------------------------------
    withName: 'SORTMERNA_INDEX' {
        cpus   = { [4, params.max_cpus as int].min() }
        memory = { [16.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time   = { [2.h, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'SORTMERNA' {
        cpus      = { [32, params.max_cpus as int].min() }
        memory    = { [64.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time      = { [8.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        maxForks  = 40
    }

   // -- Salmon initial (full Trinity, --dumpEq for Corset) -----
    withName: 'SALMON_INDEX_INITIAL' {
        cpus     = { [8, params.max_cpus as int].min() }
        memory   = { [100.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time     = { [4.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args = '--keepDuplicates'
    }
    withName: 'SALMON_QUANT_INITIAL' {
        cpus     = { [8, params.max_cpus as int].min() }
        memory   = { [64.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time     = { [8.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args = '--dumpEq'
    }

   // -- Corset + representative selection + dedup -------------------------
    withName: 'CORSET' {
        cpus       = { [32, params.max_cpus as int].min() }
        memory     = { [128.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [48.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        publishDir = [ path: "${params.outdir}/clustering", mode: 'copy' ]
    }
    withName: 'SELECT_REP' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [8.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [30.min * task.attempt, params.max_time as nextflow.util.Duration].min() }
        publishDir = [ path: "${params.outdir}/representatives", mode: 'copy' ]
    }
    withName: 'MMSEQS2_CLUSTER' {
        cpus       = { [8, params.max_cpus as int].min() }
        memory     = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [2.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        publishDir = [ path: "${params.outdir}/representatives", mode: 'copy', pattern: 'cluster_stats.txt' ]
    }

   // -- Taxonomy filter (UniRef50: 60M seqs, ~28 GB on disk) ----------------
   // Already runs as 1 split with 425G. Bottleneck is CPU-bound prefilter.
    withName: 'MMSEQS2_TAXONOMY' {
        cpus       = { [64, params.max_cpus as int].min() }
        memory     = { [[700.GB, 1000.GB, 1200.GB][task.attempt - 1], params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [72.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        publishDir = [ path: "${params.outdir}/taxonomy", mode: 'copy' ]
    }

   // -- Frameshift correction --------------------------------------------
    withName: 'DIAMOND_BLASTX' {
        cpus   = { [64, params.max_cpus as int].min() }
        memory = { [700.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time   = { [72.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'CORRECT_FRAMESHIFTS' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [8.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [1.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        publishDir = [ path: "${params.outdir}/frameshift_correction", mode: 'copy', pattern: 'frameshift_stats.txt' ]
    }

   // -- TD2 ORF prediction -----------------------------------------------
   // Strategy presets (LongOrfs -m/-M/-L, Predict -P/FDR):
   //   conservative (90/70/0.7, P 0.1, FDR 0.05)
   //   standard     (90/50/0.5, P 0.1, FDR 0.10)
   //   aggressive   (90/30/0.4, P 0.1, FDR 0.20)
   // When td2_strategy is null, individual params are used directly.
   // -P 0.1: low PSAURON floor — the pipeline removes junk via taxonomy
   //   filter + homology, so PSAURON only needs to catch obvious non-coding.
    withName: 'TD2_LONGORFS' {
        cpus     = { [8, params.max_cpus as int].min() }
        memory   = { [16.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time     = { [2.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args = {
            def s = params.td2_strategy
            def m, M, L
            if      (s == 'conservative') { m = 90; M = 70; L = 0.7 }
            else if (s == 'aggressive')   { m = 90; M = 30; L = 0.4 }
            else if (s == 'standard')     { m = 90; M = 50; L = 0.5 }
            else if (s == null)           { m = params.td2_min_orf_length; M = params.td2_abs_min_orf; L = params.td2_length_scale }
            else { error "Unknown td2_strategy: '${s}'. Use conservative, standard, or aggressive." }
            (params.td2_strand_specific ? '-S ' : '') + "-m ${m} -M ${M} -L ${L}"
        }
    }
    withName: 'TD2_PREDICT' {
        cpus          = { [1, params.max_cpus as int].min() }
        memory        = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time          = { [16.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        errorStrategy = { task.exitStatus in [1, 104, 134, 135, 137, 139, 140, 143, 247] ? 'retry' : 'finish' }
        ext.args = {
            def s = params.td2_strategy
            if      (s == 'conservative') { '-P 0.1 --retain-long-orfs-fdr 0.05' }
            else if (s == 'standard')     { '-P 0.1' }
            else if (s == 'aggressive')   { '-P 0.1 --retain-long-orfs-fdr 0.2' }
            else                          { '' }
        }
    }

   // -- MMseqs2 homology search (SwissProt 200 MB, Pfam 140 MB) -----------
   // Tiny DBs — CPU-bound, not RAM-bound.
    withName: 'MMSEQS2_SEARCH_SWISSPROT' {
        cpus       = { [32, params.max_cpus as int].min() }
        memory     = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [4.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args   = { "-s ${params.mmseqs2_search_sens}" }
        publishDir = [ path: "${params.outdir}/mmseqs2_search", mode: 'copy', pattern: '*.m8' ]
    }
    withName: 'MMSEQS2_SEARCH_PFAM' {
        cpus       = { [32, params.max_cpus as int].min() }
        memory     = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [4.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args   = { "-s ${params.mmseqs2_search_sens}" }
        publishDir = [ path: "${params.outdir}/mmseqs2_search", mode: 'copy', pattern: '*.m8' ]
    }

   // -- Best ORF selection -----------------------------------------------
    withName: 'SELECT_BEST_ORF' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [4.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [30.min, params.max_time as nextflow.util.Duration].min() }
        publishDir = [
            [ path: "${params.outdir}/annotation", mode: 'copy', pattern: '*.gff3' ],
            [ path: "${params.outdir}/annotation", mode: 'copy', pattern: '*.tsv' ]
        ]
    }

   // -- MetaEuk ORF prediction (parallel to TD2) -------------------------
    withName: 'METAEUK_PREDICT' {
        cpus       = { [32, params.max_cpus as int].min() }
        memory     = { [64.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [12.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'METAEUK_SELECT_BEST' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [4.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [1.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'PSAURON_METAEUK' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [8.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [2.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }

   // -- GeneMarkS-T ORF prediction (parallel to TD2 + MetaEuk) ----------
    withName: 'GMST_PREDICT' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [6.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'PSAURON_GMST' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [8.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [2.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }

   // -- Merge TD2 + MetaEuk + GeneMarkS-T predictions --------------------
    withName: 'MERGE_PREDICTIONS' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [4.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [30.min, params.max_time as nextflow.util.Duration].min() }
        publishDir = [
            [ path: "${params.outdir}/proteins",  mode: 'copy', pattern: '*.tsv' ],
            [ path: "${params.outdir}/proteins",  mode: 'copy', pattern: '*.txt' ]
        ]
    }

   // -- Protein-level dedup -----------------------------------------------
    withName: 'MMSEQS2_CLUSTER_PROTEIN' {
        cpus       = { [8, params.max_cpus as int].min() }
        memory     = { [16.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [1.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        publishDir = [
            [ path: "${params.outdir}/proteins",  mode: 'copy', pattern: '*.faa' ],
            [ path: "${params.outdir}/proteins",  mode: 'copy', pattern: '*.tsv' ],
            [ path: "${params.outdir}/proteins",  mode: 'copy', pattern: '*.txt' ]
        ]
    }

   // -- Salmon final (gene-level, representative transcripts) ------------
    withName: 'SALMON_INDEX_FINAL' {
        cpus   = { [8, params.max_cpus as int].min() }
        memory = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time   = { [2.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'SALMON_QUANT_FINAL' {
        cpus       = { [8, params.max_cpus as int].min() }
        memory     = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [8.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args   = '--dumpEq --writeOrphanLinks --rangeFactorizationBins 4'
        publishDir = [ path: "${params.outdir}/salmon_final", mode: 'copy' ]
    }

   // -- Validation & QC -------------------------------------------------
    withName: 'VALIDATE_IDS' {
        cpus   = { [1, params.max_cpus as int].min() }
        memory = { [2.GB, params.max_memory as nextflow.util.MemoryUnit].min() }
        time   = { [10.min, params.max_time as nextflow.util.Duration].min() }
    }
    withName: 'BUSCO_TRINITY' {
        cpus       = { [16, params.max_cpus as int].min() }
        memory     = { [64.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [24.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args   = { "-l ${params.busco_lineage} -m transcriptome" }
        publishDir = [ path: "${params.outdir}/qc", mode: 'copy' ]
    }
    withName: 'BUSCO_QC' {
        cpus       = { [16, params.max_cpus as int].min() }
        memory     = { [32.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [4.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        ext.args   = { "-l ${params.busco_lineage} -m proteins" }
        publishDir = [ path: "${params.outdir}/qc", mode: 'copy' ]
    }

   // -- Functional annotation -------------------------------------------
    // eggNOG7: 3.18M profiles, ~340 GB k-mer index, must fit in RAM
    withName: 'TRANSANNOT' {
        cpus       = { [16, params.max_cpus as int].min() }
        memory     = { [[700.GB, 1000.GB, 1200.GB][task.attempt - 1], params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [12.h * task.attempt, params.max_time as nextflow.util.Duration].min() }
        errorStrategy = { task.exitStatus in [1, 104, 134, 135, 137, 139, 140, 143, 247] ? 'retry' : 'finish' }
        publishDir = [ path: "${params.outdir}/transannot", mode: 'copy' ]
    }

   // -- Report ----------------------------------------------------------
    withName: 'THINNING_REPORT' {
        cpus       = { [1, params.max_cpus as int].min() }
        memory     = { [16.GB * task.attempt, params.max_memory as nextflow.util.MemoryUnit].min() }
        time       = { [30.min, params.max_time as nextflow.util.Duration].min() }
        publishDir = [ path: "${params.outdir}", mode: 'copy' ]
    }

}
