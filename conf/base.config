/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Resource allocations for each process — NMBU Orion HPC
    Nodes: 384 CPUs, ~1.5 TB RAM each (shared)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

// Helper function: cap resources at user-defined max
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "WARNING: Max memory '${params.max_memory}' is not valid — using default"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "WARNING: Max time '${params.max_time}' is not valid — using default"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "WARNING: Max cpus '${params.max_cpus}' is not valid — using default"
            return obj
        }
    }
}

process {
    // --- Defaults ---
    cpus          = { check_max( 1, 'cpus' ) }
    memory        = { check_max( 4.GB, 'memory' ) }
    time          = { check_max( 1.h, 'time' ) }

    // Retry on OOM / SLURM memory-kill exit codes
    errorStrategy = { task.exitStatus in [104, 134, 137, 139, 140, 143, 247] ? 'retry' : 'finish' }
    maxRetries    = 2

    // ── SortMeRNA ─────────────────────────────────────────────────────────
    withName: 'SORTMERNA_INDEX' {
        cpus   = { check_max( 4, 'cpus' ) }
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h, 'time' ) }
    }
    withName: 'SORTMERNA' {
        cpus      = { check_max( 16, 'cpus' ) }
        memory    = { check_max( 64.GB * task.attempt, 'memory' ) }  // Reduced from 72GB
        time      = { check_max( 8.h * task.attempt, 'time' ) }       // Reduced from 24h (typical runtime 2-4h)
        maxForks  = 10  // Increased from 8 for better throughput
    }

    // ── MMseqs2 nucleotide dedup ──────────────────────────────────────────
    withName: 'MMSEQS2_CLUSTER_NT' {
        cpus   = { check_max( 32, 'cpus' ) }         // Increased from 16 (better parallelization)
        memory = { check_max( 128.GB * task.attempt, 'memory' ) }  // Increased from 64GB
        time   = { check_max( 4.h * task.attempt, 'time' ) }       // Reduced from 8h (faster with more CPUs)
    }

    // ── Salmon initial (transcript-level, with --dumpEq for Corset) ──────
    withName: 'SALMON_INDEX_INITIAL' {
        cpus     = { check_max( 8, 'cpus' ) }
        memory   = { check_max( 100.GB * task.attempt, 'memory' ) }
        time     = { check_max( 4.h * task.attempt, 'time' ) }
        ext.args = '--keepDuplicates'
    }
    withName: 'SALMON_QUANT_INITIAL' {
        cpus     = { check_max( 8, 'cpus' ) }        // Reduced from 12 (sub-linear scaling beyond 8)
        memory   = { check_max( 64.GB * task.attempt, 'memory' ) }
        time     = { check_max( 8.h * task.attempt, 'time' ) }
        ext.args = '--hardFilter --dumpEq'
    }

    // ── Corset + Lace ─────────────────────────────────────────────────────
    withName: 'CORSET' {
        cpus    = { check_max( 1, 'cpus' ) }         // Reduced from 4 (single-threaded)
        memory  = { check_max( 32.GB * task.attempt, 'memory' ) }  // Reduced from 64GB
        time    = { check_max( 2.h * task.attempt, 'time' ) }      // Reduced from 8h
    }
    withName: 'LACE' {
        cpus   = { check_max( 8, 'cpus' ) }
        memory = { check_max( 64.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }
    }

    // ── Taxonomy filter (classify + filter in one step) ────────────────
    // TrEMBL DB is ~252M entries. More RAM = fewer splits = much faster.
    // Retry: 500G → 650G → 800G (each Orion node has ~1.5TB)
    withName: 'MMSEQS2_TAXONOMY' {
        cpus   = { check_max( 64, 'cpus' ) }
        memory = { check_max( [500.GB, 650.GB, 800.GB][task.attempt - 1], 'memory' ) }
        time   = { check_max( 24.h * task.attempt, 'time' ) }
    }

    // ── Frameshift correction (Diamond blastx + Python correction) ──────
    withName: 'FRAMESHIFT_CORRECTION' {
        cpus   = { check_max( 16, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }
    }

    // ── TD2 ORF prediction ───────────────────────────────────────────────
    withName: 'TD2_LONGORFS' {
        cpus   = { check_max( 8, 'cpus' ) }          // Increased from 4 (threading now enabled)
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h * task.attempt, 'time' ) }       // Reduced from 4h (faster with threading)
    }
    withName: 'TD2_PREDICT' {
        cpus   = { check_max( 1, 'cpus' ) }          // Reduced from 4 (single-threaded)
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }   // Reduced from 16GB
        time   = { check_max( 2.h * task.attempt, 'time' ) }      // Reduced from 4h
    }

    // ── MMseqs2 homology searches (run in parallel) ──────────────────────
    // SwissProt/Pfam are smaller DBs but still benefit from more threads
    // Retry: 200G → 400G → 600G
    withName: 'MMSEQS2_SEARCH_SWISSPROT' {
        cpus   = { check_max( 32, 'cpus' ) }
        memory = { check_max( [200.GB, 400.GB, 600.GB][task.attempt - 1], 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }
    }
    withName: 'MMSEQS2_SEARCH_PFAM' {
        cpus   = { check_max( 32, 'cpus' ) }
        memory = { check_max( [200.GB, 400.GB, 600.GB][task.attempt - 1], 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }
    }

    // ── Best ORF selection ───────────────────────────────────────────────
    withName: 'SELECT_BEST_ORF' {
        cpus   = { check_max( 1, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
        time   = { check_max( 30.min, 'time' ) }
    }

    // ── Salmon final (gene-level SuperTranscripts) ───────────────────────
    withName: 'SALMON_INDEX_FINAL' {
        cpus   = { check_max( 8, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h * task.attempt, 'time' ) }
    }
    withName: 'SALMON_QUANT_FINAL' {
        cpus       = { check_max( 8, 'cpus' ) }      // Reduced from 12 (sub-linear scaling beyond 8)
        memory     = { check_max( 32.GB * task.attempt, 'memory' ) }
        time       = { check_max( 8.h * task.attempt, 'time' ) }
        ext.args   = '--rangeFactorizationBins 4'
        publishDir = [ path: "${params.outdir}/salmon_final", mode: 'copy' ]
    }

    // ── Validation & QC ─────────────────────────────────────────────────
    withName: 'VALIDATE_IDS' {
        cpus   = { check_max( 1, 'cpus' ) }
        memory = { check_max( 2.GB, 'memory' ) }
        time   = { check_max( 10.min, 'time' ) }
    }
    withName: 'BUSCO_QC' {
        cpus   = { check_max( 16, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 4.h * task.attempt, 'time' ) }
    }

    // ── Functional annotation ───────────────────────────────────────────
    withName: 'TRANSANNOT' {
        cpus   = { check_max( 16, 'cpus' ) }
        memory = { check_max( 64.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }
    }

    // ── Report ──────────────────────────────────────────────────────────
    withName: 'THINNING_REPORT' {
        cpus   = { check_max( 1, 'cpus' ) }
        memory = { check_max( 4.GB, 'memory' ) }
        time   = { check_max( 30.min, 'time' ) }
    }
}
